#!/usr/bin/env python
from globalvars import storeOperatingHours
from datetime import datetime, timedelta
import pytz
import numpy as np
algorithmActive = "1"
#FUNKCJA
def convert_to_warsaw_time(utc_time_str):
    utc_time = datetime.strptime(utc_time_str, "%Y-%m-%d %H:%M")
    utc_time = pytz.utc.localize(utc_time)
    warsaw_time = utc_time.astimezone(warsawTz)
    return warsaw_time.strftime("%Y-%m-%d %H:%M")
#FUNKCJA
def parse_datetime(timestamp):
    return datetime.strptime(timestamp, "%Y-%m-%d %H:%M")
def generate_yesterday_minutes(currentDate):
    # Get today's date and subtract one day to get yesterday
    yesterday = currentDate - timedelta(days=6)
    # Set the start of the day (00:00) and end of the day (23:59) for yesterday
    start_time = yesterday.replace(hour=0, minute=0, second=0, microsecond=0) - timedelta(hours=1)
    end_time = currentDate.replace(hour=6, minute=0, second=0, microsecond=0) - timedelta(minutes=1)# - timedelta(hours=1)
    # Create a list to store all minute-based daytimes
    minutes_list = []
    # Generate each minute from start_time to end_time
    current_time = start_time
    while current_time <= end_time:
        minutes_list.append(current_time.timestamp())
        current_time += timedelta(minutes=1)
    return minutes_list
# FUNKCJA
def create_co2_object_final_optimized(attributeNameTSO, yesterdayMinutes_dt, dataTSO_dt_tuples):
    """
    Optimized function assuming both yesterdayMinutes and dataTSO_dt_tuples 
    contain native Python datetime objects for fast comparison.
    """
    # Initialize the CO2 day list
    co2_day_list = []
    co2_day_list_append = co2_day_list.append # Micro-optimization: store append method
    # 1. Handle the edge case of empty data
    if not dataTSO_dt_tuples:
        return {attributeNameTSO: [None] * len(yesterdayMinutes_dt), "TimeStamp": yesterdayMinutes_dt}
    # Pre-calculate values outside the loop for speed
    data_length = len(dataTSO_dt_tuples)
    # Access native datetime objects at index [0]
    first_datetime = dataTSO_dt_tuples[0][0] 
    first_value = dataTSO_dt_tuples[0][1] 
    data_index = 0
    # 2. Core Loop (O(N+M) logic)
    for minute in yesterdayMinutes_dt:
        # a. Handle minutes before the first data point
        # This is now a fast native datetime comparison
        if minute < first_datetime:
            co2_day_list_append(first_value)
            continue 
        # b. Advance the data_index (Two-Pointer Logic)
        # All comparisons are now fast native datetime comparisons
        while data_index < data_length - 1 and minute >= dataTSO_dt_tuples[data_index + 1][0]:
            data_index += 1
        # c. Append the value
        # The value is at index [1] of the tuple, and is already a float
        co2_day_list_append(dataTSO_dt_tuples[data_index][1])
    # 3. Final Construction
    return {attributeNameTSO: co2_day_list, "TimeStamp": yesterdayMinutes_dt}
def time_to_minutes(time_str):
    """
    Convert time in "HH:MM" format to the corresponding minute of the day.
    Parameters:
        time_str (str): A string representing time in "HH:MM" format.
    Returns:
        int: The minute of the day (0-1439).
    """
    try:
        # Split the string into hours and minutes
        hours, minutes = map(int, time_str.split(':'))
        # Validate the input
        if not (0 <= hours < 24 and 0 <= minutes < 60):
            raise ValueError("Invalid time format")
        # Calculate the minute of the day
        return hours * 60 + minutes
    except ValueError:
        raise ValueError("Time must be in the format HH:MM and within valid ranges (e.g., 23:59).")
def calculate_average(numbers):
    """
    Calculate the average of a list of numbers.
    Parameters:
        numbers (list): A list of numeric values.
    Returns:
        float: The average of the numbers in the list. Returns None for an empty list.
    """
    if not numbers:  # Check if the list is empty
        return None
    return sum(numbers) / len(numbers)
def convert_csharp_to_python_datetime(csharp_dt_object):
    # 1. Convert C# object to a Python string representation
    dt_str = str(csharp_dt_object) 
    # 2. Parse the string into a Python datetime object
    return datetime.strptime(dt_str, DATE_FORMAT)
# PRZYGOTOWANIE DAT
currentDate = datetime.utcnow()
todayDate = currentDate.replace(hour=6, minute=0, second=0, microsecond=0)
yesterdayDate = currentDate - timedelta(days=6)
yesterdayDate = yesterdayDate.replace(hour=0, minute=0, second=0, microsecond=0) - timedelta(hours=1)
yesterdayMinutes = generate_yesterday_minutes(currentDate)
DATE_FORMAT = "%d.%m.%Y %H:%M:%S" # Example format string
summed = 0
dataBase = storeOperatingHours.get()  
activeAlgorithmList = list(deviceService.GetDevicesParameterListFromMnemonic("LLO0", ["StoreIsForcedWorking"]))#[0:1]
fullIdList = []
for item in activeAlgorithmList:
    fullIdList.append(item.FullIdentifier)
dataLLO = deviceRecordsService.GetRawRecords(["StoreIsForcedWorking", "StoreIsForcedWorkingEnable"], fullIdList, yesterdayDate, todayDate)
#allowedAlgorithmList = deviceRecordsService.GetRawRecords(["StoreIsForcedWorkingEnable"], fullIdList, yesterdayDate, todayDate)
dataDownloaded = {}
for i in range(len(dataLLO)):
    if dataLLO[i].FullIdentifier not in dataDownloaded:
        dataDownloaded[dataLLO[i].FullIdentifier] = {}
    dataDownloaded[dataLLO[i].FullIdentifier][dataLLO[i].Name] = dataLLO[i]
alarms = []
for item in dataDownloaded:      
    attributeNameLLO = "StoreIsForcedWorking"
    if "StoreIsForcedWorking" not in dataDownloaded[item] or "StoreIsForcedWorkingEnable" not in dataDownloaded[item]:
        continue
    dataLLO_StoreIsForcedWorking = dataDownloaded[item]["StoreIsForcedWorking"].Data
    dataLLO_StoreIsForcedWorkingEnable = dataDownloaded[item]["StoreIsForcedWorkingEnable"].Data
    fullIdentifier = item
    storeMpk = fullIdentifier[4:8]
    coldMinutes = 0
    coldMinutes7daysAgo = 0
    coldMinutes6daysAgo = 0
    coldMinutes5daysAgo = 0
    coldMinutes4daysAgo = 0
    coldMinutes3daysAgo = 0
    coldMinutes2daysAgo = 0
    coldMinutes1daysAgo = 0
    coldMinutes0daysAgo = 0
    dataLLO_fast = []
    dataLLO_Enable_fast = []
    for obj in dataLLO_StoreIsForcedWorking:
        dataLLO_fast.append((convert_csharp_to_python_datetime(obj.DateTime).timestamp(), float(obj.Value)))
    for obj in dataLLO_StoreIsForcedWorkingEnable:
        dataLLO_Enable_fast.append((convert_csharp_to_python_datetime(obj.DateTime).timestamp(), float(obj.Value)))    
    dataTSO = create_co2_object_final_optimized(attributeNameLLO, yesterdayMinutes, dataLLO_fast)[attributeNameLLO]
    dataTSO_Enable = create_co2_object_final_optimized("StoreIsForcedWorkingEnable", yesterdayMinutes, dataLLO_Enable_fast)["StoreIsForcedWorkingEnable"]
    for minute in range(len(dataTSO)):
        if minute <= 420 or (minute >= 1440 and  minute <= 1860) or (minute >= 2880 and  minute <= 3300) or (minute >= 4320 and  minute <= 4740) or (minute >= 5760 and  minute <= 6180) or (minute >= 7200 and  minute <= 7620) or minute >= 8640:        
            if dataTSO[minute] == 1 and dataTSO_Enable[minute] == 1:
                coldMinutes += 1
                if minute < 1440:
                    coldMinutes6daysAgo += 1
                elif minute < 2880:
                    coldMinutes5daysAgo += 1
                elif minute < 4320:
                    coldMinutes4daysAgo += 1
                elif minute < 5760:
                    coldMinutes3daysAgo += 1
                elif minute < 7200:
                    coldMinutes2daysAgo += 1 
                elif minute < 8640:
                    coldMinutes1daysAgo += 1
                elif minute < 9060:
                    coldMinutes0daysAgo += 1
    if coldMinutes > 0:               
        alarms.append({"mpk": storeMpk, "tooColdMinutes": round(coldMinutes / 60, 1), "tooColdMinutes6daysAgo": round(coldMinutes6daysAgo, 1), "tooColdMinutes5daysAgo": round(coldMinutes5daysAgo, 1), "tooColdMinutes4daysAgo": round(coldMinutes4daysAgo, 1), "tooColdMinutes3daysAgo": round(coldMinutes3daysAgo, 1), "tooColdMinutes2daysAgo": round(coldMinutes2daysAgo, 1), "tooColdMinutes1daysAgo": round(coldMinutes1daysAgo, 1), "tooColdMinutes0daysAgo": round(coldMinutes0daysAgo, 1)})
def addTableToMail(table, header, textAbove, alarms):
    if not table:        
        table = f"{header}<h1>{textAbove}</h1>"
    else:
        table = f"{table}<h1>{textAbove}</h1>"
    table = f"{table}<table class='old-table'><tr class='firstRow'>"
    table = f"{table}<td>MPK</td><td>Czas zapalenia +1h</td><td>Czas zapalenia +1h 6 dni temu</td><td>Czas zapalenia +1h 5 dni temu</td><td>Czas zapalenia +1h 4 dni temu</td><td>Czas zapalenia +1h 3 dni temu</td><td>Czas zapalenia +1h 2 dni temu</td><td>Czas zapalenia +1h 1 dzień temu</td><td>Czas zapalenia +1h dzisiaj</td></tr>"
    previousMPK = None
    whiteRow = True
    for alarm in alarms:        
        if previousMPK != alarm["mpk"]:
            whiteRow = not whiteRow
        if whiteRow:
            table = f'{table}<tr><td>{alarm["mpk"]}</td><td>{alarm["tooColdMinutes"]}</td><td>{alarm["tooColdMinutes6daysAgo"]}</td><td>{alarm["tooColdMinutes5daysAgo"]}</td><td>{alarm["tooColdMinutes4daysAgo"]}</td><td>{alarm["tooColdMinutes3daysAgo"]}</td><td>{alarm["tooColdMinutes2daysAgo"]}</td><td>{alarm["tooColdMinutes1daysAgo"]}</td><td>{alarm["tooColdMinutes0daysAgo"]}</td></tr>'
        else:
            table = f'{table}<tr bgcolor="Wheat"><td>{alarm["mpk"]}</td><td>{alarm["tooColdMinutes"]}</td><td>{alarm["tooColdMinutes6daysAgo"]}</td><td>{alarm["tooColdMinutes5daysAgo"]}</td><td>{alarm["tooColdMinutes4daysAgo"]}</td><td>{alarm["tooColdMinutes3daysAgo"]}</td><td>{alarm["tooColdMinutes2daysAgo"]}</td><td>{alarm["tooColdMinutes1daysAgo"]}</td><td>{alarm["tooColdMinutes0daysAgo"]}</td></tr>'
        previousMPK = alarm["mpk"]    
    table = f"{table}</tr></table></br></br>"
    return table   
header = "<style>.old-table{border-collapse:collapse;border-style:hidden;    border-width:1px;    border-style:solid;    border-color:black;    font-family:Montserrat;    font-size:11px;    text-align:center;}.old-table td {    border:1px solid black;    padding:8;}.old-table th{    border:1pxsolidblack;    padding:4;}.firstRow{    background-color:#e67e22;    color:white;}h1{    font-family:Montserrat;    font-size:21px;}h2{    font-family:Montserrat;    font-size:16px;} .outer-table {border-collapse: collapse;border-spacing: 0px;} .outer-table td {padding: 0;} .inner-table { border-collapse: collapse; border-spacing: 0;font-family:Montserrat;    font-size:11px;    text-align:center;} .inner-table td {border: 1px solid black;padding: 8;} </style>"
table = ""
alarms.sort(key=lambda x: x["tooColdMinutes"], reverse=True) 
table = addTableToMail(table, header, "Załączenia przycisku +1h - Tygodniowe", alarms)
emailService.SendEmail("cze@solwena.pl", "Załączenia przycisku +1h - Tygodniowe", table) 
#emailService.SendEmail("pawel.wieczorek@jeronimo-martins.com", "Załączenia przycisku +1h", table) 
#emailService.SendEmail("arkadiusz.rak@solwena.com", "Załączenia przycisku +1h", table) 
emailService.SendEmail("wojciech.spierewka@solwena.com", "Załączenia przycisku +1h - Tygodniowe", table) 
emailService.SendEmail("maksym.kostiuchenko@solwena.com", "Załączenia przycisku +1h - Tygodniowe", table) 
#emailService.SendEmail("aleksandra.kaminska@solwena.com", "Załączenia przycisku +1h - Tygodniowe", table)
